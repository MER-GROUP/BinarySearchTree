package test;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

/**
 * Created by M.E.R.lin aka Maxim Ramanenka on 05.08.2015 - 10.08.2015.
 * Привет друзья и остальные !
 * 6 дней у меня ушло на написание своего бинарное дерева поиска...
 * писал для того чтобы изучить деревья ...
 * вроде изучил (с седьмой попытки!!! -) Tree007 а были еще 001... , зато тер как отчи наш с деревьями -))) )...
 * но чтобы написать свое бинарное дерево поиска я целый мецяц изучал
 * 1)Связные списки (односвязные , двусвязные)
 * 2)Графы (ориентированые и не ориентированые)
 * 3)Деревья (это вид графа - поэтому я графы и изучал) и какие они бывают.
 *  а бывает их много ) : рекомендую обратить внимание :
 *                                      -бинорное дерево (бинарная куча)
 *                                      -бинарное дерево поиска
 *                                      -АВЛ дерево
 *                                      -красно-черное дерево
 *                                      -В-дерево
 *                                      -ну и по желаю можно на другие посмотреть ...
 * Также в своих программах советую и рекомендую оставлять комментарии - если бы не коментарии я бы писал
 * это дерево больше бы 6-ти дней ...
 * Также при написании этого дерева я делал упор на :
 *                                              -инкапсуляцию
 *                                              -полиморфизм
 *                                              -коментарии
 *                                              -(наследавание интерфейса Comparable идет по умолчанию)
 * Почему я решил выложить этот код в общее обозрение ? спросите вы
 * Отвечаю - хорошего кода с коментариями в интернете нет - я информацию замучился искать ...
 * поэтому этот код - будет мне и не только служить справочником по основным алгоритмам реализации
 * бинарного дерево поиска ...
 * Реализаованные методы :
 * addRec - рекурсивно
 * addIter - итерационно
 * infixRec - обход дерева в глубину рекурсивно в симметричном порядке
 * infixIter - обход дерева итерационно в симметричном порядке
 * prefixRec - обход дерева в глубину рекурсивно в прямом порядке
 * prefixIter - обход дерева итеративно в прямом порядке
 * postfixRec - обход дерева в глубину рекурсивно в обратном порядке
 * postfixIter - обход дерева в глубину итеративно в обратном порядке
 * print - обход дерева в ширину только итеративно (с лево на право)
 * findMinRec - поиск минимального узла в корне дерева (рекурсивно)
 * findMinIter - поиск минимального узла в корне дерева (итеративно)
 * findMaxRec - поиск максимального узла в корне дерева (рекурсивно)
 * findMaxIter - поиск максимального узла в корне дерева (итеративно)
 * findRec - поиск заданного узла в дерева (рекурсивно)
 * findIter - поиск заданного узла в дерева (итеративно)
 * delMinRec - удаляем минимальный узел в дереве (рекурсивно)
 * delMinIter - удаляем минимальный узел в дереве (итеративно)
 * delMaxRec - удаляем максимальный узел в дереве (рекурсивно)
 * delMaxIter - удаляем максимальный узел в дереве (итеративно)
 * delRec - удаляем указанный узел в дереве (ипользуя наши методы класса, + рекурсия)
 * delIter - удаляем указанный узел в дереве (ипользуя наши методы класса, + итерация)
 * hasParent - проверка есть ли у нода родитель
 * getParent - проверка есть ли у нода родитель
 * leftRotare - повернем дерево в заданном узле на лево
 * rightRotare - повернем дерево в заданном узле на право
 * getHeightNode - определение высоты дерева у нода
 * balance - балансировка дерева
 * В коментариях могут быть опечатки и может не очень гдето хорошо я выразил свою мысль
 * Код на идеал не претендует - кто захочет тот найдет тут ошибки ...
 * Еще раз повтарю - писалось это чтобы изучить деревья ...
 * Сподвигло чтобы я написал это - это сайт javarush.ru (изучение языка JAVA).
 * Чтобы решить четвертую бонусную задачу из двадцатого уровня пришлось разобраться в деревьях, графах, списках ...
 * Ну чтож ... приятного просмотра кода и изучения бинарного дерева поиска -) УДАЧИ !
 */
public class Tree007 {
    public static class Node{//-----------------------------------------------------------------------------------------
        //значение узла/////////////////////////////////////////////////////////////////////////////////////////////////
        private Comparable data;
        //левое поддерево
        private Node left;
        //правое поддерево
        private Node right;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //constructor///////////////////////////////////////////////////////////////////////////////////////////////////
        public Node(Comparable data) {
            setData(data);
            setLeft(null);
            setRight(null);
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getter and setter data////////////////////////////////////////////////////////////////////////////////////////
        public Comparable getData() {
            return data;
        }
        public void setData(Comparable data) {
            this.data = data;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getter and setter left////////////////////////////////////////////////////////////////////////////////////////
        public Node getLeft() {
            return left;
        }
        public void setLeft(Node left) {
            this.left = left;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getter and setter right///////////////////////////////////////////////////////////////////////////////////////
        public Node getRight() {
            return right;
        }
        public void setRight(Node right) {
            this.right = right;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }//-----------------------------------------------------------------------------------------------------------------

    public static class Tree{//-----------------------------------------------------------------------------------------
        //корень дерева/////////////////////////////////////////////////////////////////////////////////////////////////
        private Node root;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //construct/////////////////////////////////////////////////////////////////////////////////////////////////////
        public Tree() {
            //при инициализации дерева корень дерева задаем как null
            setRoot(null);
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getter and setter root////////////////////////////////////////////////////////////////////////////////////////
        public Node getRoot() {
            return root;
        }
        public void setRoot(Node root) {
            this.root = root;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //add - рекурсивно//////////////////////////////////////////////////////////////////////////////////////////////
        public void addRec(Comparable data){
            //добавление узла
            setRoot(addRec(data,getRoot()));
        }
        private Node addRec(Comparable data, Node node){
            //при рекурсии создавать родителя не надо !!!
            // (но иногда есть исключения см. delMinRec(),delMaxRec() и то мы его не создаем а возвращаем !!!)
            //поэтому в рекурсиях родители не создаются , но могут возвращаться !!!!!
            //т.к. любое поддерево принимает родителя и задает исходя из этого свое поведение
            //если корень равен null
            if (null==node){
                //то текущий корень указать на новый узел
                node=new Node(data);
            }
            //если вставляемое значение меньше значения текущего узла
            else if (data.compareTo(node.getData())<0){
                //то рекурсивно перехожу к левому поддереву
                node.setLeft(addRec(data,node.getLeft()));
            }
            //если вставляемое значение равно или больше значения текущего узла
            else {
                //то рекурсивно перехожу к правому поддереву
                node.setRight(addRec(data,node.getRight()));
            }
            return node;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //add - итерационно/////////////////////////////////////////////////////////////////////////////////////////////
        public void addIter(Comparable data){
            //если корень null
            if (null==getRoot()){
                //то создаем первый новый узел
                setRoot(new Node(data));
            }
            //иначе начать обход
            else {
                setRoot(addIter(data,getRoot()));
            }
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node addIter(Comparable data, Node node){
            //при итерации создавать родителя НАДО !!!
            //т.к. связи с нодом - родителем НЕТ !
            //если корень равен null
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //создаем Node родитель
            Node parent=null;
            //покуда дерево не null
            while (node!=null){
                //если вставляемое значение меньше значения текущего узла
                if (data.compareTo(node.getData())<0){
                    //помечаем родителя
                    parent=node;
                    //и итеративно перехожу к левому поддереву
                    node=node.getLeft();
                }
                //если вставляемое значение больше значения текущего узла
                else {
                    //помечаем родителя
                    parent=node;
                    //и итеративно перехожу к правому поддереву
                    node=node.getRight();
                }
            }
            //нашли null узел куда вставляем новый узел
            node=new Node(data);
            //и смотрим если значение нового узла меньше значения родителя
            //то новый нод вставляем в левое поддерево родителя иначе вправое поддерево родителя
            if (node.getData().compareTo(parent.getData())<0){
                parent.setLeft(node);
            }else {
                parent.setRight(node);
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //infix - обход дерева в глубину рекурсивно в симметричном порядке//////////////////////////////////////////////
        public void infixRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            infixRec(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void infixRec(Node node){
            //рекурсивно спускаемся по левому поддереву
            if (node.getLeft()!=null) {
                infixRec(node.getLeft());
            }
            //выводим в консоль значение узла
            System.out.print(node.getData() + " ");
            //рекурсивно спускаемся по правому поддереву
            if (node.getRight()!=null){
                infixRec(node.getRight());
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //infix - обход дерева итерационно в симметричном порядке///////////////////////////////////////////////////////
        //обход бинарного дерева в глубину в симетричном порядке (итеративно)
        //из текущего узла спускаемся до самого нижнего левого узла,
        //добавляя в стек все посещенные узлы.
        //обрабатываем верхний узел из стека (вершину стека). если в текущем узле имеется правое поддерево,
        //начинаем следующую итерацию с правого узла. если правого узла нет,
        //пропускаем шаг со спуском и переходим к обработке следующего узла из стека
        public void infixIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            infixIter(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void infixIter(Node node){
            //создаем стек нодов
            Stack<Node> stack=new Stack<>();
            //покуда node не null иди стек не пуст
            while (node!=null || !stack.empty()){
                //если стек не пустой то вершину вырезать и передать ноду
                if (!stack.empty()){
                    //вырезаем вершину из стека и передаем ноду
                    node=stack.pop();
                    //выводим в консоль значение узла
                    System.out.print(node.getData() + " ");
                    //если есть у node правое поддерево
                    if (node.getRight()!=null){
                        //то нод указываю на его
                        node=node.getRight();
                    }
                    //иначе зануляю нод, чтобы взять следующий нод из стека
                    else {
                        node=null;
                    }
                }
                //покуда node не null
                while (node!=null){
                    //если узел не null то его добавляем в стей
                    stack.push(node);
                    //и переходим в левое поддерево
                    node=node.getLeft();//в итоге node станет null
                }
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //prefix - обход дерева в глубину рекурсивно в прямом порядке///////////////////////////////////////////////////
        public void prefixRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            prefixRec(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void prefixRec(Node node){
            //выводим в консоль значение узла
            System.out.print(node.getData() + " ");
            //рекурсивно спускаемся по левому поддереву
            if (node.getLeft()!=null) {
                prefixRec(node.getLeft());
            }
            //рекурсивно спускаемся по правому поддереву
            if (node.getRight()!=null){
                prefixRec(node.getRight());
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //prefix - обход дерева итеративно в прямом порядке/////////////////////////////////////////////////////////////
        //обход бинарного дерева в глубину в прямом порядке (итеративно)
        //обрабатываем текущий узел, при наличии правого поддерева добавляем его в стек
        //для последующей обработки. переходим к узлу левого поддерева.
        //если левого узла нет, переходим к верхнему узлу из стека
        public void prefixIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            prefixIter(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void prefixIter(Node node){
            //создаем стек нодов
            Stack<Node> stack=new Stack<>();
            //покуда node не null иди стек не пуст
            while (node!=null || !stack.empty()){
                //если стек не пустой то вершину вырезать и передать ноду
                if (!stack.empty()){
                    //передаем вершину стека ноду
                    node=stack.pop();
                }
                //покуда node не null
                while (node!=null){
                    //выводим в консоль значение узла
                    System.out.print(node.getData() + " ");
                    //и если есть правое плддерево у нода то добавляем его в стек
                    if (node.getRight()!=null){
                        stack.push(node.getRight());
                    }
                    //и переходим в левое поддерево
                    node=node.getLeft();
                }
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //postfix - обход дерева в глубину рекурсивно в обратном порядке////////////////////////////////////////////////
        public void postfixRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            postfixRec(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void postfixRec(Node node){
            //рекурсивно спускаемся по левому поддереву
            if (node.getLeft()!=null) {
                postfixRec(node.getLeft());
            }
            //рекурсивно спускаемся по правому поддереву
            if (node.getRight()!=null){
                postfixRec(node.getRight());
            }
            //выводим в консоль значение узла
            System.out.print(node.getData() + " ");
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //postfix - обход дерева в глубину итеративно в обратном порядке////////////////////////////////////////////////
        //обход бинарного дерева в глубину в обратном порядке (итеративно)
        //делаем кодирование непосредственно в очередности стека - при спуске,
        //если у очередного узла позже нужно будет обработать еще правое поддерево,
        //в стек вносится последовательность - родитель, правый узел, родитель.
        //таким образом, при обработке узлов из стека мы сможем определить,
        //нужно ли нам обрабатывать правое поддерево.
        public void postfixIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            postfixIter(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void postfixIter(Node node){
            //создаем стек нодов
            Stack<Node> stack=new Stack<>();
            //покуда node не null иди стек не пуст
            while (node!=null || !stack.empty()){
                //если стек не пустой
                if (!stack.empty()){
                    //берем вершину стека и кладем в нод
                    node=stack.pop();
                    //если стек не пуст и правое поддерево нода равно вершине стека
                    //(это мы проверяем были ли в правом поддереве текущего нода или нет)
                    //и если условие совподает то мы не были в в правом поддереве текущего нода
                    if (!stack.empty() && node.getRight()==stack.peek()){
                        //если небыли то ноду присваиваем вершину стека
                        node=stack.pop();
                    }
                    //если мы были в правом поддереве
                    else {
                        //выводим в консоль значение узла
                        System.out.print(node.getData() + " ");
                        //и зануляю нод, чтобы взять следующий нод из стека
                        node=null;
                    }
                }
                //покуда node не null
                while (node!=null){
                    //добавляем узел в стек
                    stack.push(node);
                    //если правое поддерево нода не null, то в стек добавляем правое поддерево узла
                    //и потом снова сам узел
                    if (node.getRight()!=null){
                        stack.push(node.getRight());
                        stack.push(node);
                    }
                    //и переходим в левое поддерева нода
                    node=node.getLeft();
                }
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //print - обход дерева в ширину только итеративно (с лево на право)/////////////////////////////////////////////
        //обход бинарного дерева в ширину (итерационно)
        //обрабатываем первый в очереди узел, при наличии дочерних узлов
        //заносим их в конец очереди. переходим к следующей итерации
        public void print(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            print(getRoot());
            //переход курсора в консоли на следующую строку
            System.out.println();
        }
        private void print(Node node){
            //создаем очередь нодов
            Queue<Node> queue=new LinkedList<>();
            //покуда нод не null и очередь нодов не пуста
            while (node!=null || !queue.isEmpty()){
                //если очередь не пуста
                if (!queue.isEmpty()){
                    //то ноду присваиваем вершину очереди
                    node=queue.poll();
                }
                //покуда нод не null
                while (node!=null){
                    //выводим в консоль значение узла
                    System.out.print(node.getData() + " ");
                    //если левое поддерево нода не null
                    //то заносим нод в очередь
                    if (node.getLeft()!=null){
                        queue.add(node.getLeft());
                    }
                    //если правое поддерево нода не null
                    //то заносим нод в очередь
                    if (node.getRight()!=null){
                        queue.add(node.getRight());
                    }
                    //и потом зануляем нод, чтобы взять следующий нод из вершины очереди
                    node=null;
                }
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //findMin - поиск минимального узла в корне дерева (рекурсивно)/////////////////////////////////////////////////
        public Node findMinRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findMinRec(getRoot());
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findMinRec(Node node){
            //рекурсивно спускаемся в левое поддерева корня и возвращаем его (минимальное значение)
            //если хочеш рекурсивно добраться до последнего элеиента (последний нод !!!) и его вернуть,
            //то всегда рекурсию пиши в return
            //это применяеися в том случае если надо вернуть только одно условие !!!
            return (node.getLeft()!=null ? findMinRec(node.getLeft()) : node);
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //findMin - поиск минимального узла в корне дерева (итеративно)/////////////////////////////////////////////////
        public Node findMinIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findMinIter(getRoot());
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findMinIter(Node node){
            //покуда левое поддерево корня не null
            while (node.getLeft()!=null){
                //переходим в левое поддерево корня
                node=node.getLeft();
            }
            //возвращаем минимальный узел корня
            return node;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //findMax - поиск максимального узла в корне дерева (рекурсивно)////////////////////////////////////////////////
        public Node findMaxRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findMaxRec(getRoot());
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findMaxRec(Node node){
            //рекурсивно спускаемся в правое поддерева корня и возвращаем его (максимальное значение)
            //если хочеш рекурсивно добраться до последнего элеиента (последний нод !!!) и его вернуть,
            //то всегда рекурсию пиши в return
            //это применяеися в том случае если надо вернуть только одно условие !!!
            return (node.getRight()!=null ? findMaxRec(node.getRight()) : node);
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //findMax - поиск максимального узла в корне дерева (итеративно)////////////////////////////////////////////////
        public Node findMaxIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findMaxIter(getRoot());
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findMaxIter(Node node){
            //покуда правое поддерево корня не null
            while (node.getRight()!=null){
                //переходим в левое поддерево корня
                node=node.getRight();
            }
            //возвращаем минимальный узел корня
            return node;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //find - поиск заданного узла в дерева (рекурсивно)/////////////////////////////////////////////////////////////
        public Node findRec(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findRec(getRoot(), value);
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findRec(Node node, Comparable value){
            //определим условия если искомого нода нет или есть
            //(это делаем для того чтобы вернуть только искомый один нод (последний нод !!!)
            // т.к спускаться по дереву будем в return'е)
            //это наше условие прерывания рекурсии
            //если нода нет
            if (node==null){
                //то возвращвем null
                return null;
            }
            //иначе если нод есть т.е. искомое значениеесть в дереве
            else if (value.compareTo(node.getData())==0){
                //возвращаем искомы нод
                return node;
            }

            //рекурсивно ищем узел в return, т.к. мы хотим вернуть одно значение, т.е. один узел
            //и искать будем самим методом класса
            //т.е. условие поиска задаю в самам методе класса причем в return'е !!!
            //это применяеися в том случае если надо вернуть из двух и более условий только одно !!!
            return findRec(
                            //если значение искомого узла меньше значения текущего узла
                            //т.е. первым значение я передаю нод
                            //вторым параметр value
                            value.compareTo(node.getData()) < 0 ?
                                    //то переходим в левое поддерево текущего узла
                                    node.getLeft() :
                                    //иначе переходим в правое поддерево
                                    node.getRight()
                            ,//и передаем искомое значение, т.е. параметр value
                            value
                        );
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //find - поиск заданного узла в дерева (итеративно)/////////////////////////////////////////////////////////////
        public Node findIter(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return getRoot();
            }
            //иначе начать обход
            return findIter(getRoot(), value);
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node findIter(Node node, Comparable value){
            //покуда нод не null
            while (node!=null){
                //если значение искомого узла равно значению текущего узла
                if (value.compareTo(node.getData())==0){
                    //то возвращаем найденный узел
                    return node;
                }
                //если значение искомого узла меньше значения текущего узла
                else if (value.compareTo(node.getData())<0){
                    //то переходим в левое поддерево
                    node=node.getLeft();
                }
                //если значение искомого узла больше значения текущего узла
                else {
                    //то переходим в правое поддерево
                    node=node.getRight();
                }
            }
            //если ничего не нашли то возвращаем null
            //или возвращаем node - он тоже будет null
            return null;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //delMin - удаляем минимальный узел в дереве (рекурсивно)///////////////////////////////////////////////////////
        public void delMinRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delMinRec(getRoot()));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delMinRec(Node node){
            //сдесь возвращаемый нод это родитель !!!
            //если левое поддерево нода не null
            if (node.getLeft()!=null){
                //то рекурсивно переходим в левое поддерево
                node.setLeft(delMinRec(node.getLeft()));
                //это наш родитель - возвращаем его root'у
                return node;
            }
            //если левое поддерево нода null
            //то ноду присваиваем его правое подерево
            //тоесть мы в минимальный узел всталяем его правое поддерево
            else {
                return node.getRight();
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //delMin - удаляем минимальный узел в дереве (итеративно)///////////////////////////////////////////////////////
        public void delMinIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delMinIter(getRoot()));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delMinIter(Node node){
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //создаем Node родитель для нода
            Node parent=null;
            //если левое поддерево нода не null
            while (node.getLeft()!=null){
                //помечаем родителя
                parent=node;
                //и итерационно переходим в левое поддерево нода
                node=node.getLeft();
            }
            //дошли до минимального узла
            //и минимальному узлу присваеваю его правое поддерево (оно может быть null или не null)
            //(это наш будущий потомок)
            node=node.getRight();
            //и родительскому левому поддереву присваиваю новый нод
            //(это окажется или null или правая ветка бывшего минимального узла)
            //если родитель текущего нода не null, то в левое поддерево родителя записываем нод
            if (parent!=null) {
                parent.setLeft(node);
            }
            //иначе голове записываем нод
            else {
                head=node;
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //delMax - удаляем максимальный узел в дереве (рекурсивно)//////////////////////////////////////////////////////
        public void delMaxRec(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delMaxRec(getRoot()));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delMaxRec(Node node) {
            //сдесь возвращаемый нод это родитель !!!
            //если правое поддерево нода не null
            if (node.getRight() != null) {
                //то рекурсивно переходим в правое поддерево
                node.setRight(delMaxRec(node.getRight()));
                //это наш родитель - возвращаем его root'у
                return node;
            }
            //если правое поддерево нода null
            //то ноду присваиваем его левое подерево
            //тоесть мы в максимальный узел всталяем его левое поддерево
            else {
                return node.getLeft();
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //delMax - удаляем максимальный узел в дереве (итеративно)//////////////////////////////////////////////////////
        public void delMaxIter(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delMaxIter(getRoot()));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delMaxIter(Node node){
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //создаем Node родитель для нода
            Node parent=null;
            //если правое поддерево нода не null
            while (node.getRight()!=null){
                //помечаем родителя
                parent=node;
                //и итерационно переходим в правое поддерево нода
                node=node.getRight();
            }
            //дошли до максимума узла
            //и максимальному узлу присваеваю его левое поддерево (оно может быть null или не null)
            //(это наш будущий потомок)
            node=node.getLeft();
            //и родительскому правому поддереву присваиваю новый нод
            //(это окажется или null или левая ветка бывшего максимального узла)
            //если родитель текущего нода не null, то в правое поддерево родителя записываем нод
            if (parent!=null) {
                parent.setRight(node);
            }
            //иначе голове записываем нод
            else {
                head=node;
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //del - удаляем указанный узел в дереве (ипользуя наши методы класса, + рекурсия)///////////////////////////////
        public void delRec(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delRec(getRoot(), value));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delRec(Node node,Comparable value){
            //ищем на узел для удаления
            //если нет текущего узла, то возвращаем null (это потомок с присвоинным null)
            if (node==null) return null;
            //если значение искомого узла меньше значения текущего узла
            //то рекурсивно переходим в левое поддерево текущего узла
            else if (value.compareTo(node.getData()) < 0) node.setLeft(delRec(node.getLeft(), value));
            //если значение искомого узла больше значения текущего узла
            //то рекурсивно переходим в правое поддерево текущего узла
            else if (value.compareTo(node.getData()) > 0) node.setRight(delRec(node.getRight(), value));
            //иначе если нашли узел и у него есть два ребенка
            else if (node.getLeft()!=null && node.getRight()!=null){
                //значение минимального элемента правого поддерева присваиваю удаляемому узлу
                //ипользуем приватный метод нахождения минимального узла от заданного узла private findMinRec()
                node.setData(findMinRec(node.getRight()).getData());
                //и удаляем минимальный узел в правом поддереве текущего узла
                //тоже используем приватный метод
                //мы воспользовались рекурсивным удалением - а рекурсия в этом методе возвращает родителя
                //поэтому мы текущему ноду присвоили потомка с удаленным минимумом
                //можно было бы воспользоваться приватным итеративным методом delMinIter() он ничего не возвращает
                //а меняет все в структуре дерева delMinIter(node.getRight());
                //но мне рекурсия больше нравится - т.к. с рекурсией меньше кода, хотя это личный выбор каждого !
                node.setRight(delMinRec(node.getRight()));
            }
            //иначе если нашли узел и у него есть один ребенок
            else {
                //если у текущего узла есть левый ребонок то им заменяем текущий нод иначе заменяем правым
                node=(node.getLeft()!=null ? node.getLeft() : node.getRight());
            }
            //возвращаем родителя
            return node;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //del - удаляем указанный узел в дереве (ипользуя наши методы класса, + итерация)///////////////////////////////
        public void delIter(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(delIter(getRoot(),value));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node delIter(Node node,Comparable value){
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //создаем Node родитель для нода
            Node parent=null;
            //находим искомый узел
            //покуда нод не null
            while (node!=null){
                //если искомое значение меньше текущего узла, то переходим итерационно в левое поддерево текущего узла
                if (value.compareTo(node.getData()) < 0){
                    //помечаем родителя
                    parent=node;
                    //переходим итерационно в левое поддерево текущего узла
                    node=node.getLeft();
                }
                //если искомое значение больше текущего узла, то переходим итерационно в правое поддерево текущего узла
                else if (value.compareTo(node.getData()) > 0){
                    //помечаем родителя
                    parent=node;
                    //переходим итерационно в левое поддерево текущего узла
                    node=node.getRight();
                }
                //если нашли узел то выходим из цикла
                else break;
            }
            //если искомый узел есть, т.е. не null, то удаляем его
            if (node!=null){
                //если у удаляемого узла есть двое детей
                //тут не играет роли есть родитель или нет ! (т.к. я использую приватные методы класса)
                if (node.getLeft()!=null && node.getRight()!=null){
                    //то текущему ноду присваиваю из правого поддерева значение минимального узла
                    //сдесь я решил воспользоваться приватным итеративным методом findMinIter
                    node.setData(findMinIter(node.getRight()).getData());
                    //и из текущего нода из правого поддерева удаляю минимальный узел
                    node.setRight(delMinIter(node.getRight()));
                }
                //если у текущего нода есть родитель
                if (parent!=null){
                    //выясняем текущий нод это левое или правое поддерево родителя
                    //если текущий нод это левое поддерево родителя
                    if (node==parent.getLeft()){
                        //если у текущего нода нет детей
                        if (node.getLeft()!=null && node.getRight()!=null){
                            //то левому поддереву родителя присваеваем null
                            parent.setLeft(null);
                        }
                        //если есть хотябы один ребенок
                        else {
                            //то левому поддереву родителя задаю значение из условия
                            //если у текущего нода левое поддерево не null то текущему ноду присваиваю левое поддерево
                            //иначе присваиваю правое поддерево
                            parent.setLeft(node.getLeft()!=null ? node.getLeft() : node.getRight());
                        }
                    }
                    //если текущий нод это правое поддерево родителя
                    else {
                        //если у текущего нода нет детей
                        if (node.getLeft()!=null && node.getRight()!=null){
                            //то правому поддереву родителя присваеваем null
                            parent.setRight(null);
                        }
                        //если есть хотябы один ребенок
                        else {
                            //то правому поддереву родителя задаю значение из условия
                            //если у текущего нода левое поддерево не null то текущему ноду присваиваю левое поддерево
                            //иначе присваиваю правое поддерево
                            parent.setRight(node.getLeft() != null ? node.getLeft() : node.getRight());
                        }
                    }
                }
                //если у текущего нода нет родителя
                else {
                    //если у текущего нода нет детей
                    if (node.getLeft()!=null && node.getRight()!=null){
                        //то голове связного списка задаю null
                        head=null;
                    }
                    //если есть хотябы один ребенок
                    else {
                        //то голове связного списка задаю значение из условия
                        //если у текущего нода левое поддерево не null то текущему ноду присваиваю левое поддерево
                        //иначе присваиваю правое поддерево
                        head = (node.getLeft()!=null ? node.getLeft() : node.getRight());
                    }
                }
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //hasParent - проверка есть ли у нода родитель//////////////////////////////////////////////////////////////////
        public boolean hasParent(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return false;
            }
            //иначе начать обход
            return hasParent(getRoot(),value);
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private boolean hasParent(Node node,Comparable value){
            //создаем голову связного списка
            Node head=node;
            //проверяем есть ли узел в дереве
            //если узла нет в дереве то возвращаем false, тобиш нет родителя
            //при этом используем внутренний приватный метод класса findIter
            //но прежде найдем искомый нод
            Node find=findIter(head,value);
            //если искомого нода нет , то и родителя нет
            if (null==find) return false;
            //если голова null, то возвращаем false
            else if (null==head) return false;
            //если узел есть в дереве и он равен голове (корню дерева) то у узла нет родителя
            else if (head==find) return false;
            //иначе у нода есть родитель
            else return true;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getParent - проверка есть ли у нода родитель//////////////////////////////////////////////////////////////////
        public Node getParent(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return null;
            }
            //иначе начать обход
            return getParent(getRoot(), value);
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node getParent(Node node,Comparable value){
            //если родителя у нода нет то вернуть null,
            // сдесь тоже использую внутренний приваиный метод класса hasParent
            if (!hasParent(node,value)) return null;
            //иначе начинаем искать родителя
            else {
                //создаем Node родитель для нода
                Node parent=null;
                //находим искомый узел
                //покуда нод не null
                while (node!=null){
                    //если искомое значение меньше текущего узла,
                    // то переходим итерационно в левое поддерево текущего узла
                    if (value.compareTo(node.getData()) < 0){
                        //помечаем родителя
                        parent=node;
                        //переходим итерационно в левое поддерево текущего узла
                        node=node.getLeft();
                    }
                    //если искомое значение больше текущего узла,
                    // то переходим итерационно в правое поддерево текущего узла
                    else if (value.compareTo(node.getData()) > 0){
                        //помечаем родителя
                        parent=node;
                        //переходим итерационно в левое поддерево текущего узла
                        node=node.getRight();
                    }
                    //если нашли узел то выходим из цикла
                    else break;
                }
                //возвращаем родителя
                return parent;
            }
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //leftRotare - повернем дерево в заданном узле на лево//////////////////////////////////////////////////////////
        //чтобы поворачивать ноды дерева надо чтобы у поворачиваемого нода был нод родитель
        //для этого напишем методы hasParent - проверка есть ли у нода родитель
        //и getParent - получение у нода родителя
        public void leftRotare(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(leftRotare(getRoot(), value));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node leftRotare(Node node,Comparable value){
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //ищем узел который хотим повернкть на лево
            //тоже использую приватный метод класса findIter
            Node child=findIter(head,value);
            //проверяю если есть у текущего нода родитель, то делаю поворот в лево
            //и также проверяю является ли этот нод правым поддеревом родителя
            if (hasParent(head,value)){
                //получаю родителя, тоже использую приватный метод класса
                Node parent=getParent(head,value);
                //и также проверяю является ли этот нод правым поддеревом родителя
                //есди да то делаем левый поворот
                if (child==parent.getRight()){
                    //дальше будет два вида поворота если у родителя есть дедушка или если у родиля нет дедушки
                    //если у родителя есть дедушка
                    if (hasParent(head,parent.getData())){
                        //получаем дедушку
                        Node grand=getParent(head,parent.getData());
                        //и начиваем левый поворот
                        //if Родитель==Дед.L то Дед.L(Родитель.R)
                        //else Родитель==Дед.R то Дед.R(Родитель.R)
                        //Родитель.R(Сын.L)
                        //Сын.L(Родитель)

                        //если родитель это левое поддерево деда
                        if (parent==grand.getLeft()){
                            //дедушке в левое поддерево присваиваю правое поддерево родителя
                            grand.setLeft(parent.getRight());
                        }
                        //если родитель это правое поддерево деда
                        else {
                            //дедушке в правое поддерево присваиваю правое поддерево родителя
                            grand.setRight(parent.getRight());
                        }

                        //родителю в правое поддерево присваиваю левое поддерево сына
                        parent.setRight(child.getLeft());
                        //сыну в левое поддерево присваиваю родителя
                        child.setLeft(parent);
                    }
                    //если у родителя нет дедушки
                    else {
                        //и начиваем левый поворот
                        //Родитель.R(Сын.L)
                        //Сын.L(Родитель)
                        //Голова(Сын)
                        //родителю в правое поддерево присваиваю левое поддерево сына
                        parent.setRight(child.getLeft());
                        //сыну в левое поддерево присваиваю родителя
                        child.setLeft(parent);
                        //т.к. голова съехала в низ и ребенок стал головой
                        //то то голове присваиваем ребенка
                        head=child;
                    }
                }
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //rightRotare - повернем дерево в заданном узле на право////////////////////////////////////////////////////////
        //чтобы поворачивать ноды дерева надо чтобы у поворачиваемого нода был нод родитель
        //для этого напишем методы hasParent - проверка есть ли у нода родитель
        //и getParent - получение у нода родителя
        public void rightRotare(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(rightRotare(getRoot(), value));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node rightRotare(Node node,Comparable value){
            //Создаем голову возвращаемого связного списка
            Node head=node;
            //ищем узел который хотим повернкть на право
            //тоже использую приватный метод класса findIter
            Node child=findIter(head,value);
            //проверяю если есть у текущего нода родитель, то делаю поворот в право
            //и также проверяю является ли этот нод левым поддеревом родителя
            if (hasParent(head,value)){
                //получаю родителя, тоже использую приватный метод класса
                Node parent=getParent(head,value);
                //и также проверяю является ли этот нод левым поддеревом родителя
                //есди да то делаем правый поворот
                if (child==parent.getLeft()){
                    //дальше будет два вида поворота если у родителя есть дедушка или если у родиля нет дедушки
                    //если у родителя есть дедушка
                    if (hasParent(head,parent.getData())){
                        //получаем дедушку
                        Node grand=getParent(head,parent.getData());
                        //и начиваем правый поворот
                        //if Родитель==Дед.L то Дед.L(Родитель.L)
                        //else Родитель==Дед.R то Дед.R(Родитель.L)
                        //Родитель.L(Сын.R)
                        //Сын.R(Родитель)

                        //если родитель это левое поддерево деда
                        if (parent==grand.getLeft()){
                            //дедушке в левое поддерево присваиваю левое поддерево родителя
                            grand.setLeft(parent.getLeft());
                        }
                        //если родитель это правое поддерево деда
                        else {
                            //дедушке в правое поддерево присваиваю левое поддерево родителя
                            grand.setRight(parent.getLeft());
                        }

                        //родителю в левое поддерево присваиваю правое поддерево сына
                        parent.setLeft(child.getRight());
                        //сыну в правое поддерево присваиваю родителя
                        child.setRight(parent);
                    }
                    //если у родителя нет дедушки
                    else {
                        //и правый поворот левый поворот
                        //Родитель.L(Сын.R)
                        //Сын.R(Родитель)
                        //Голова(Сын)
                        //родителю в левое поддерево присваиваю правое поддерево сына
                        parent.setLeft(child.getRight());
                        //сыну в правое поддерево присваиваю родителя
                        child.setRight(parent);
                        //т.к. голова съехала в низ и ребенок стал головой
                        //то то голове присваиваем ребенка
                        head=child;
                    }
                }
            }
            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //getHeightNode - определение высоты дерева у нода//////////////////////////////////////////////////////////////
        //возвращаемые значениея : -1 токого узла нет или не существует дерево
        //если корень равен узлу : то высота ноль (высоты глявного корня дерева равно 0)
        // 1 и т.д. высотв поддеревьев корня
        public int getHeightNode(Comparable value){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return -1;
            }
            //иначе начать обход
            return getHeightNode(getRoot(),value);
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private int getHeightNode(Node node,Comparable value){
            //создадим счеичик уровня дерева
            //-1 : нет дерева или узла
            //0 : узел равен корню
            //1 и т.д. : правые или левые поддеревья
            int heightNodaCount=-1;
            //найдем узел в дереве (используя приваиный метод класса findIter)
            Node find=findIter(node,value);
            //если узел существует в дереве
            if (find!=null){
                //инкрементировать счетчик (какая то высота есть)
                heightNodaCount++;
                //покуда голова связного списка не равна найденному ноду
                while (find!=node){
                    //если искомый нод меньше текущего нода
                    if (find.getData().compareTo(node.getData()) < 0){
                        //то в текущем ноде итерационно переходим в левое поддерево
                        node=node.getLeft();
                        //и инкрементруем высоту дерева
                        heightNodaCount++;
                    }
                    //если искомый нод больше текущего нода
                    else {
                        //то в текущем ноде итерационно переходим в правое поддерево
                        node=node.getRight();
                        //и инкрементруем высоту дерева
                        heightNodaCount++;
                    }
                }
            }
            //возвращаем высоту нода в дереве
            return heightNodaCount;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //balance - балансировка дерева/////////////////////////////////////////////////////////////////////////////////
        //для балансировки дерева мне нужно знать высоту узла в дереве
        //поэтому напишем метод getHeightNode() - которая будет возвращать высоту нода в дереве
        public void balance(){
            //если корень null
            if (null==getRoot()){
                //то ничего не выводить
                return;
            }
            //иначе начать обход
            setRoot(balance(getRoot()));
            //переход курсора в консоли на следующую строку
            //System.out.println();
        }
        private Node balance(Node node){
            //алгоритм я придумал очень простой ! (не стал пересочинять велосипеды т.к. есть красно-черные деревья
            // и авл-деревья в JAVA (красно-черные деревья) это ассосиативное множесство TreeSet и
            // ассоциативный контейнер TreeMap)
            //я просто буду поворачивать
            //родителей минимальных или максимальных узлов корня дерева
            //взависимости от высоты минамального и максимального узлов корня дерева
            // и соответственно у нас никогда дерево не будет равнятся связному линейному списку !
            //естественно в реальных проектах применять это не стоит , но за основу взять можно.
            //алгоритм такой :
            //покуда минимальный узел корня дерева меньше максимального узла корня дерева
            //и разница высот максимального и минимального улов корня дерева больше 1
            //while (Root(min)<Root(max) && Room(max)-Root(min)>1)
            //      {
            //          //то поворачиваем родителя максимального узла корня дерева в лево
            //          rotareLeft(Root(max).parent);
            //      }
            //покуда минимальный узел корня дерева больше максимального узла корня дерева
            //и разница высот минимального и максимального улов корня дерева больше 1
            //while (Root(min)>Root(max) && Root(min)-Root(max)>1)
            //      {
            //          //то поворачиваем родителя минимального узла корня дерева в право
            //          rotateRight(Root(min).parent);
            //      }

            //Создаем голову возвращаемого связного списка
            Node head=node;

            //получим максимальный узел дерева
            //используем приватные методы класса ...
            Node maxNode=findMaxIter(head);
            //получим минимальный узел дерева
            Node minNode=findMinIter(head);
            //получим родителя максимального узла дерева
            Node maxNodeParent=getParent(head,maxNode.getData());
            //получим родителя минимального узла дерева
            Node minNodeParent=getParent(head,minNode.getData());

            //получаем высоту минимального узла корня дерева
            // (используем приватный методы классов getHeightNode и findMinIter)
            int minNodeRoot=getHeightNode(head,minNode.getData());
            //получаем высоту максимального узла корня дерева
            // (используем приватный методы классов getHeightNode и findMaxIter)
            int maxNodeRoot=getHeightNode(head,maxNode.getData());

            //покуда минимальный узел корня дерева меньше максимального узла корня дерева
            //и разница высот максимального и минимального улов корня дерева больше 1
            while (minNodeRoot<maxNodeRoot && maxNodeRoot-minNodeRoot>1){
                //то поворачиваем родителя максимального узла корня дерева в лево
                //используем приватные методы класса leftRotare
                head=leftRotare(head,maxNodeParent.getData());

                //получаем высоту минимального узла корня дерева
                // (используем приватный методы классов getHeightNode и findMinIter)
                minNodeRoot=getHeightNode(head,minNode.getData());
                //получаем высоту максимального узла корня дерева
                // (используем приватный методы классов getHeightNode и findMaxIter)
                maxNodeRoot=getHeightNode(head,maxNode.getData());
            }
            //покуда минимальный узел корня дерева больше максимального узла корня дерева
            //и разница высот минимального и максимального улов корня дерева больше 1
            while (minNodeRoot>maxNodeRoot && minNodeRoot-maxNodeRoot>1){
                //то поворачиваем родителя минимального узла корня дерева в право
                //используем приватные методы класса rightRotare
                head=rightRotare(head,minNodeParent.getData());

                //получаем высоту минимального узла корня дерева
                // (используем приватный методы классов getHeightNode и findMinIter)
                minNodeRoot=getHeightNode(head,minNode.getData());
                //получаем высоту максимального узла корня дерева
                // (используем приватный методы классов getHeightNode и findMaxIter)
                maxNodeRoot=getHeightNode(head,maxNode.getData());
            }

            //возвращаем голову связного списка
            return head;
        }///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }//-----------------------------------------------------------------------------------------------------------------

    //main
    public static void main(String[] args) {
        //test001 addRec
        System.out.println("test001 addRec---------------------------------------------------------------------------");
        Tree tree=new Tree();
        tree.addRec(10);
        tree.addRec(6);
        tree.addRec(7);
        tree.infixRec();
        //test002 addIter
        System.out.println("test002 addIter--------------------------------------------------------------------------");
        tree.addIter(19);
        tree.addIter(25);
        tree.addIter(30);
        tree.infixRec();
        //test003 infixRec
        System.out.println("test003 infixRec-------------------------------------------------------------------------");
        tree.infixRec();
        //test004 infixIter
        System.out.println("test004 infixIter------------------------------------------------------------------------");
        tree.infixIter();
        //test005 prefixRec
        System.out.println("test005 prefixRec------------------------------------------------------------------------");
        tree.prefixRec();
        //test006 prefixIter
        System.out.println("test006 prefixIter-----------------------------------------------------------------------");
        tree.prefixIter();
        //test007 postfixRec
        System.out.println("test007 postfixRec-----------------------------------------------------------------------");
        tree.postfixRec();
        //test008 postfixIter
        System.out.println("test008 postfixIter----------------------------------------------------------------------");
        tree.postfixIter();
        //test009 print
        System.out.println("test009 print----------------------------------------------------------------------------");
        tree.print();
        //test010 findMinRec
        System.out.println("test010 findMinRec-----------------------------------------------------------------------");
        System.out.println(tree.findMinRec().getData());
        //test011 findMinIter
        System.out.println("test011 findMinIter----------------------------------------------------------------------");
        System.out.println(tree.findMinIter().getData());
        //test012 findMaxRec
        System.out.println("test012 findMaxRec-----------------------------------------------------------------------");
        System.out.println(tree.findMaxRec().getData());
        //test013 findMaxIter
        System.out.println("test013 findMaxIter----------------------------------------------------------------------");
        System.out.println(tree.findMaxIter().getData());
        //test014 findRec
        System.out.println("test014 findRec--------------------------------------------------------------------------");
        System.out.println(tree.findRec(19).getData());
        System.out.println(tree.findRec(199));
        //test015 findIter
        System.out.println("test015 findIter-------------------------------------------------------------------------");
        System.out.println(tree.findIter(19).getData());
        System.out.println(tree.findIter(199));
        //test016 delMinRec
        System.out.println("test016 delMinRec------------------------------------------------------------------------");
        tree.delMinRec();
        tree.infixRec();
        //test017 delMinIter
        System.out.println("test017 delMinIter-----------------------------------------------------------------------");
        tree.delMinIter();
        tree.infixRec();
        //test018 delMaxRec
        System.out.println("test018 delMaxRec------------------------------------------------------------------------");
        tree.delMaxRec();
        tree.infixRec();
        //test019 delMaxIter
        System.out.println("test019 delMaxIter-----------------------------------------------------------------------");
        tree.delMaxIter();
        tree.infixRec();
        //test020 add's new node in tree
        System.out.println("test020 add's new node in tree-----------------------------------------------------------");
        tree.addRec(6);
        tree.addRec(7);
        tree.addRec(19);
        tree.addRec(25);
        tree.addRec(22);
        tree.infixRec();
        //test021 delRec
        System.out.println("test021 delRec---------------------------------------------------------------------------");
        tree.delRec(10);
        tree.infixRec();
        tree.delRec(100);
        tree.infixRec();
        //test022 delIter
        System.out.println("test022 delIter--------------------------------------------------------------------------");
        tree=new Tree();
        tree.addRec(9);
        tree.addRec(6);
        tree.addRec(4);
        tree.addRec(7);
        tree.addRec(16);
        tree.addRec(10);
        tree.addRec(19);
        tree.addRec(17);
        tree.infixRec();
        tree.print();
        tree.delIter(17);//del
        tree.infixRec();
        tree.print();
        //test023 hasParent
        System.out.println("test023 hasParent------------------------------------------------------------------------");
        System.out.println(tree.hasParent(6));
        System.out.println(tree.hasParent(17));
        System.out.println(tree.hasParent(19));
        System.out.println(tree.hasParent(9));
        System.out.println(tree.hasParent(4));
        //test024 getParent
        System.out.println("test024 getParent------------------------------------------------------------------------");
        System.out.println(tree.getParent(6).getData());
        System.out.println(tree.getParent(17));
        System.out.println(tree.getParent(19).getData());
        System.out.println(tree.getParent(9));
        System.out.println(tree.getParent(4).getData());
        System.out.println(tree.getParent(7).getData());
        //test025 leftRotare
        System.out.println("test025 leftRotare-----------------------------------------------------------------------");
        tree=new Tree();
        tree.addIter(8);
        tree.addIter(5);
        tree.addIter(2);
        tree.addIter(6);
        tree.addIter(15);
        tree.addIter(10);
        tree.addIter(9);
        tree.addIter(13);
        tree.addIter(35);
        tree.addIter(20);
        tree.addIter(40);
        tree.infixIter();
        tree.print();
        tree.leftRotare(13);
        tree.infixIter();
        tree.print();
        //test026 rightRotare
        System.out.println("test026 rightRotare----------------------------------------------------------------------");
        tree=new Tree();
        tree.addIter(9);
        tree.addIter(5);
        tree.addIter(2);
        tree.addIter(1);
        tree.addIter(3);
        tree.addIter(7);
        tree.addIter(6);
        tree.addIter(8);
        tree.addIter(15);
        tree.addIter(10);
        tree.addIter(35);
        tree.infixIter();
        tree.print();
        tree.rightRotare(2);
        tree.infixIter();
        tree.print();
        tree.prefixIter();
        tree.postfixIter();
        //test027 getHeightNode
        System.out.println("test027 getHeightNode--------------------------------------------------------------------");
        System.out.println(tree.getHeightNode(45));
        System.out.println(tree.getHeightNode(0));
        System.out.println(tree.getHeightNode(9));
        System.out.println(tree.getHeightNode(2));
        System.out.println(tree.getHeightNode(8));
        System.out.println(tree.getHeightNode(7));
        //test028 balance
        System.out.println("test028 balance--------------------------------------------------------------------------");
        tree=new Tree();
        tree.addIter(10);
        tree.addIter(9);
        tree.addIter(8);
        tree.addIter(7);
        tree.addIter(6);
        tree.addIter(5);
        tree.infixIter();
        tree.print();
        tree.balance();
        tree.infixIter();
        tree.print();
    }
}
